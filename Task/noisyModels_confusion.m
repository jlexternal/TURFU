% Simulated data from generative model, confusion matrix 
%
%   Name:   noisyModels_confusion.m
% Author:   Jun Seok Lee
%   Date:   May 2019
%   Type:   Script
%   Note:   For the TURFU experiment

load('infNoiseParamsLog','infNoiseParamsLog');
load('selNoiseParamsLog','selNoiseParamsLog');

global blockFilter;
global globCond;
global globParticleCount;
blockFilter = 'direction';
globCond = 1;
globParticleCount = 2500;

% BADS settings
addpath(genpath('bads-master')); % load the BADS files into working directory\
% Changing parameter tolerance options on BADS
options = [];
options.TolMesh = 0.01;

% Script variables
futurecond = false;

% Fixed model parameters for simulation
hazRts  = [.1 .25 .45];
sigmas  = [.33 .66 1];
etas    = [.15 .3 .5]; % for +selNoise model only 

% Model score:
%                           Recovered by:
%                       infN         selN    
%                   |___________|____________|
%                   |           |            |
% Generated by: infN|    1,1    |     1,2    |
%                   |-----------|------------|
%               selN|    2,1    |     2,2    |
%                   |___________|____________|
modelScore = zeros(2,2); 
        
% Blocks to simulate on
fileSubj = 1;   % using the past condition blocks from subject 1 (but it really doesn't matter the condition)
filename = dir(sprintf('Data/TURFU_S%02d_*.mat', fileSubj));
filename = filename.name;
load(sprintf('Data/%s',filename));
clearvars fileSubj filename;
blocks = find([expe.blck.taskid] == 1 & [expe.blck.condtn]~=3);

trajectoryTest = true;

% Create temporary 'expe' structure to be passed through to the particle filters
tempexpe = struct;
for iblock = 1:10
    if ismember(iblock, blocks)
        tempexpe.blck(iblock).taskid = 1;
        tempexpe.blck(iblock).seqllr = expe.blck(iblock).seqllr;
        tempexpe.blck(iblock).seqang = expe.blck(iblock).seqang;
    else
        tempexpe.blck(iblock).taskid = 2;
    end
end
clearvars expe;
expe = tempexpe; % make 'tempexpe', 'expe'
clearvars tempexpe;

%% Simulated data generation
% 1. Get modelLL for the generative model on its own simulated data with the generative
%   parameters. 
% 2. Run BADS with the non-generative model on the data, use LogSumExp as the objective fn to find the
%   parameters of best fit. Once found, run the particle filter again but with
%   log-likelihood as the objective fn to compare w/ the generative model. 
infN_infN_lls = [];
infN_selN_lls = [];
selN_infN_lls = [];
selN_selN_lls = [];
for hazRt = hazRts
    for sigma = sigmas
        % simulate infNoise data here
        disp(['Running on parameters: H: ' num2str(hazRt) ' and sigma: ' num2str(sigma)]);
        % retrieving and parsing experimental data into simulator
        for block = blocks
            seqllrs     = expe.blck(block).seqllr;
            nsamples    = [];
            for itrial = 1:72
                nsamples = horzcat(nsamples, numel(expe.blck(block).seqang{itrial}));
            end
            
            expe.rslt(block).resp = infNoiseGlaze_simulator(hazRt, sigma, seqllrs, nsamples, futurecond);
            
            if trajectoryTest
                traject = [];
                traject2 = [];
                for itest=1:1000
                    traject = vertcat(traject,selNoiseGlaze_simulator(0.114499664306641,0.342766571044922,0.416742019653320,seqllrs,nsamples,0));
                    traject2= vertcat(traject2,infNoiseGlaze_simulator(hazRt, sigma, seqllrs, nsamples, futurecond));
                end
                
                
                plot([1:72], mean(traject(:,2:73)),'Color','r');
                hold on;
                shadedErrorBar([1:72], mean(traject(:,2:73)), std(traject(:,2:73)),'lineprops',{'--','Color','r'},'transparent',1,...
                                        'patchSaturation',.2);
                plot([1:72], mean(traject2(:,2:73)),'Color','b');
                shadedErrorBar([1:72], mean(traject2(:,2:73)), std(traject(:,2:73)),'lineprops',{'--','Color','b'},'transparent',1,...
                                        'patchSaturation',.2);
                scatter([1:72], expe.rslt(block).resp(2:73));
                hold off;
                pause;
            end
            
            
        end %blocks
        
        % Run the infNoise model PF with the current H and sigma, record the modelLL
        getmodelLL      = true;
        params          = [hazRt sigma];
        infN_infN_ll    = infNoiseGlaze_PF_recov(params, getmodelLL, futurecond);
        infN_infN_lls   = vertcat(infN_infN_lls, [params infN_infN_ll]);
       
        % Run BADS to find selNoise model params
        startPt = [rand().*.5 rand() rand()];   % vector corresponding to values of parameters to be estimated
        lBound  = [0   0  0];                   % HARD lower bound of parameter values
        uBound  = [1   1  2];                   % HARD upper bound of parameter values
        pLBound = [.05 0  .01];                 % Plausible lower bound of parameter values (optional)
        pUBound = [.9  .9 1];                   % Plausible upper bound of parameter values (optional)
        txt     = 1;    x1 = [];     clf;       % text bs for BADS visuals
        [optiParams, fVal] = bads(@selNoiseGlaze_PF, startPt, lBound, uBound, pLBound, pUBound, [], options);
        
        % Run the selNoise model PF with recovered H, sigma and eta, record modelLL
        getmodelLL      = true;
        infN_selN_ll    = selNoiseGlaze_PF_recov(optiParams, getmodelLL, futurecond);
        infN_selN_lls   = vertcat(infN_selN_lls, [optiParams infN_selN_ll]);
        
        % See which one wins and update modelScore
        if infN_infN_ll < infN_selN_ll
            modelScore(1,1) = modelScore(1,1) + 1;
        else
            modelScore(1,2) = modelScore(1,2) + 1;
        end
        
        for eta = etas
            % simulate selNoise data here
            disp(['Running on parameters: H: ' num2str(hazRt) ', sigma: ' num2str(sigma) 'and eta: ' num2str(eta)]);
            % retrieving and parsing experimental data into simulator
            for block = blocks
                seqllrs     = expe.blck(block).seqllr;
                nsamples    = [];
                for itrial = 1:72
                    nsamples = horzcat(nsamples, numel(expe.blck(block).seqang{itrial}));
                end
                expe.rslt(block).resp = selNoiseGlaze_simulator(hazRt, sigma, eta, seqllrs, nsamples, futurecond);
            end %blocks

            % Run the selNoise model PF with the current H, sigma and eta, record the modelLL
            getmodelLL      = true;
            params          = [hazRt sigma eta];
            selN_selN_ll    = infNoiseGlaze_PF_recov(params, getmodelLL, futurecond);
            selN_selN_lls   = vertcat(selN_selN_lls, [params selN_selN_ll]);

            % Run BADS to find infNoise model params
            startPt = [rand().*.5 rand()];  % vector corresponding to values of parameters to be estimated
            lBound  = [0   0];              % HARD lower bound of parameter values
            uBound  = [1   1];              % HARD upper bound of parameter values
            pLBound = [.05 0];              % Plausible lower bound of parameter values (optional)
            pUBound = [.9 .9];              % Plausible upper bound of parameter values (optional)
            txt = 1; x1 = []; clf;          % text bullshit for BADS visuals
            [optiParams, fVal] = bads(@infNoiseGlaze_PF, startPt, lBound, uBound, pLBound, pUBound, [], options);

            % Run the infNoise model PF with recovered H and sigma, record modelLL
            getmodelLL      = true;
            selN_infN_ll    = infNoiseGlaze_PF_recov(optiParams, getmodelLL, futurecond);
            selN_infN_lls   = vertcat(selN_infN_lls, [optiParams selN_infN_ll]);

            % See which one wins and update modelScore
            if selN_selN_ll < selN_infN_ll
                modelScore(2,2) = modelScore(2,2) + 1;
            else
                modelScore(2,1) = modelScore(2,1) + 1;
            end
        end
    end
end

%% testing

infN_infN_ctr = 0;
infN_selN_ctr = 0;
selN_selN_ctr = 0;
selN_infN_ctr = 0;
for i=1:size(infN_infN_lls,1)
    if infN_infN_lls(i,3) < infN_selN_lls(i,4)
        infN_infN_ctr = infN_infN_ctr + 1;
    else
        infN_selN_ctr = infN_selN_ctr + 1;
    end
end
infN_infN_ctr./9
infN_selN_ctr./9

for i=1:size(selN_selN_lls,1)
    
    if selN_selN_lls(i,3) == .5
        disp(['selN_selN/selN_infN : ' num2str(selN_selN_lls(i,4)) ':' num2str(selN_infN_lls(i,3))]);
    end
    
    if selN_selN_lls(i,4) < selN_infN_lls(i,3)
        selN_selN_ctr = selN_selN_ctr + 1;
    else
        selN_infN_ctr = selN_infN_ctr + 1;
    end
end
selN_selN_ctr./27
selN_infN_ctr./27

%% Confusion Matrix
infN_bics = []; % BIC infN ; BIC selN
selN_bics = []; % BIC infN ; BIC selN

k       = [2 3];    % number of parameters for inf and sel noise models
n       = 288;      % number of trials per inferential direction condition (postdictive)

bic = @(n, k, ll) (log(n).*k) - (2.*ll);

modelScore = zeros(2,2);

disp(sprintf('\ninfNoise generated data comp:'));
for i=1:size(infN_infN_lls,1)
    
    
    if bic(n,k(1),-infN_infN_lls(i,3)) < bic(n,k(2),-infN_selN_lls(i,4))
        disp([num2str(bic(n,k(1),-infN_infN_lls(i,3))) ' ' num2str(bic(n,k(2),-infN_selN_lls(i,4)))]);
        modelScore(1,1) = modelScore(1,1) + 1;
    else
        disp([num2str(bic(n,k(1),-infN_infN_lls(i,3))) ' ' num2str(bic(n,k(2),-infN_selN_lls(i,4))) ' eta: ' num2str(infN_selN_lls(i,3))]);
        modelScore(1,2) = modelScore(1,2) + 1;
    end
end
disp(' ');
disp('selNoise generated data comp:');
for i=1:size(selN_selN_lls,1)
    if bic(n,k(1),-selN_infN_lls(i,3)) < bic(n,k(2),-selN_selN_lls(i,4)) %wrong win
        disp([num2str(bic(n,k(1),-selN_infN_lls(i,3))) ' ' num2str(bic(n,k(2),-selN_selN_lls(i,4))) ' eta: ' num2str(selN_selN_lls(i,3))]);
        modelScore(2,1) = modelScore(2,1) + 1;
    else                                                                 %right win
        disp([num2str(bic(n,k(1),-selN_infN_lls(i,3))) ' ' num2str(bic(n,k(2),-selN_selN_lls(i,4)))]);
        modelScore(2,2) = modelScore(2,2) + 1;
    end
end
label = {'infNoise' 'infNoise + selNoise'};
confusionchart(modelScore,label);


